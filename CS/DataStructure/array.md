### 배열(Array)

- **배열(Array)**은 동일한 타입의 데이터를 저장하는 **연속적인 메모리 공간**으로 구성된 자료구조 이다
  각 데이터는 고유한 **인덱스(index)**를 가지며, 이를 통해 빠르게 접근할 수 있다

#### 특징

1. **메모리 구조**
   - 배열은 **메모리 상에서 연속적으로** 배치된다
   -  즉, 배열의 첫 번째 요소에서 n번째 요소로 이동하는 데 추가적인 메모리 조회가 필요하지 않다

2. **고정된 크기**
   - 배열은 생성 시 크기를 정해야 하며, **생성 후 크기를 변경할 수 없다**
   - 배열의 크기는 고정되지만, 배열 내 원소의 값은 언제든지 변경 가능하다

#### 시간 복잡도

1. **원소 접근**:  
   - **O(1)** (인덱스를 알고 있는 경우)  
     배열의 인덱스를 사용해 원하는 위치에 바로 접근할 수 있으므로 매우 빠르다

2. **특정 값 검색**:  
   - **O(n)** (선형 검색)  
     배열에서 특정 값을 찾으려면 처음부터 끝까지 순차적으로 확인해야 하므로 시간 복잡도는 배열의 크기에 비례한다

3. **삽입/삭제**:  
   - **O(n)**  
     배열은 연속된 메모리 공간을 사용하기 때문에, **중간**이나 **앞쪽**에 삽입하거나 삭제하려면 데이터를 이동해야 한다
     - **삽입**: 중간에 원소를 삽입할 경우, 삽입 위치 이후의 원소들을 한 칸씩 뒤로 이동해야 한다 
     - **삭제**: 중간에 원소를 삭제할 경우, 삭제된 위치 이후의 원소들을 한 칸씩 앞으로 이동해야 한다
     - **끝에서의 삽입/삭제**는 데이터 이동이 필요 없으므로 **O(1)**의 시간 복잡도를 가진다

#### 장점

1. **빠른 접근 속도**
   - 인덱스를 이용한 원소 접근은 **O(1)**으로 매우 빠흐다
     (예: `arr[3]`으로 네 번째 요소에 바로 접근 가능)

2. **메모리 효율성**
   - 배열은 연속된 메모리를 사용하므로 **메모리 관리가 간단**하고 효율적이다

#### 단점

1. **크기 제한**
   - 배열은 생성 시 크기가 고정되므로, 크기를 변경하려면 새로운 배열을 생성하고 데이터를 복사해야 한다

2. **삽입/삭제의 비효율성**
   - 중간에 원소를 삽입하거나 삭제할 경우 나머지 데이터를 이동해야 하므로 비용이 크다
     (시간 복잡도 **O(n)**)

3. **메모리 낭비**
   - 배열 크기를 초과하지 않도록 여유 공간을 할당하면 사용되지 않는 메모리 공간이 발생할 수 있다
