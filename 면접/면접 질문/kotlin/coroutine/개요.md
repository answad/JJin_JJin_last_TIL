코루틴은 'Co'와 'routine'이 합쳐진 용어로, os가 아닌 프로그램에서 관리하는 작업 단위 이다
이를 좀 더 쉽게 설명하자면, 코루틴은 스레드의 아주 경량화된 버전으로 생각할 수 있다

우선, 스레드는 운영체제(커널)가 관리하는 작업의 기본 단위이다
스레드는 독립적으로 실행되고, CPU는 여러 스레드를 빠르게 전환하면서 동시에 실행되는 것처럼 보이게 한다

이러한 스레드를 생성하고 관리하는 데에는 많은 자원이 소모된다
각 스레드는 고유의 메모리 공간을 가지고 있으며, 스레드를 생성하는 데 시간이 들고, 그 관리에도 오버헤드가 발생한다
또한, 여러 스레드가 동일한 데이터에 접근할 때 충돌이 일어날 수 있기 때문에, 이 문제를 해결하기 위한 동기화 코드가 필요하다
이러한 동기화는 코드 복잡도를 증가시키고, 유지보수도 어렵게 만든다
그리고 스레드를 전환할 때, CPU는 작업 내용을 저장하고 불러오는동작을 포함한 컨텍스트 스위칭을 통해 이전 작업 상태를 저장하고 새 작업 상태를 불러와야 하므로 추가적인 시간 소모가 발생한다

이와 같은 문제를 해결하기 위해 코루틴이 등장했다
코루틴은 운영체제가 아닌 프로그램 자체에서 관리되며, 하나의 스레드 내에서 여러 코루틴이 실행될수있다 
코루틴은 자원을 매우 적게 사용한다는 장점이 있다 
코루틴은 메모리와 CPU 자원을 스레드보다 훨씬 효율적으로 사용하기 때문에, 대규모 비동기 작업을 효율적으로 처리할 수 있다
또한, 코루틴은 하나의 스레드 안에서 실행되므로 동기화 문제가 없고, 서로 다른 코루틴들이 공유하는 자원에 대해 충돌을 걱정할 필요가 없다
각 코루틴은 프로그램 안에서 독립적인 작업 단위로 실행되서, 작업 전환이 빠르고 간단하다
예를 들어, 스레드 전환에서 발생하는 복잡한 오버헤드를 피할 수 있어, 비동기 작업의 성능을 높일 수 있다
또한, 코루틴은 작업 흐름을 명확하게 나누어 처리하기 때문에, 디버깅도 쉽다

그럼에도 불구하고 코루틴에는 몇 가지 단점도 있다
가장 큰 단점은 CPU를 많이 사용하는 작업에 대해 성능 저하가 발생할 수 있다는 것이다
코루틴은 하나의 스레드 내에서 실행되므로, CPU 중심 작업이 있을 경우, 해당 작업이 완료될 때까지 다른 코루틴들이 실행되지 못하는 경우가 발생할 수 있다
예를 들어, 코루틴에서 CPU를 많이 사용하는 계산 작업을 처리하는 경우, 다른 비동기 작업들이 지연되거나 처리되지 않을 수 있다
이런 상황을 방지하기 위해, CPU 집약적인 작업은 코루틴이 아닌 별도의 스레드에서 처리하거나, `Dispatchers.Default`와 같은 분산 처리 방식을 사용할수 있다.............
