StateFlow는 Kotlin Coroutines의 Flow를 확장한 API로

항상 하나의 현재 상태 값을 유지하고
이 값을 관찰하는 구독자들에게 값이 변경될 때마다 즉시 전파하는 특성을 가진 Hot Stream이다
StateFlow는 상태(state) 중심의 UI나 비즈니스 로직에서 사용하기 적합하고 
StateFlow는 구독자가 존재하지 않아도 계속 동작하며, 항상 `.value` 속성을 통해 현재 값을 즉시 조회할 수 있다
변경이 발생하면 이를 구독 중인 모든 observer에게 전달한다
중요한 점은 이 전달은 suspend 함수가 아닌 즉시 발생하며, 중복된 값이 emit되면 기본적으로 전달되지 않는다 (즉, `.value`에 같은 값을 설정하면 내부적으로 무시됨)
이 특성은 UI에서 무의미한 재렌더링을 방지하는 데 유리하다. 구독자는 `collect`나 Compose에서는 `collectAsState()`를 통해 값을 관찰할 수 있으며, 항상 최신 상태를 반영하도록 설계되어 있다

SharedFlow는 이벤트 기반의 데이터 흐름을 처리하기 위해 설계된 Flow로, 상태를 저장하지 않는다
SharedFlow는 기본적으로 replay 버퍼가 0이기 때문에, 이벤트가 emit되는 시점에 수집 중인 구독자만 해당 이벤트를 받을 수 있다
따라서 이벤트 emit 시점에 collect 하고있지 않으면 이벤트는 사라지고
이는 UI에서 일회성 이벤트, 예를 들어 Toast 메시지, 네비게이션 트리거, Snackbar, 클릭 응답 등과 같은 처리에 적합하다
SharedFlow는 `.emit()` 또는 `.tryEmit()`을 통해 값을 전송하며, 필요한 경우 `replay` 값을 설정해서 최근 이벤트를 버퍼링하여 늦게 구독한 구독자에게도 과거 이벤트를 재전달할 수 있다
다만, 이 경우에도 상태처럼 현재 값을 보존하는 것은 아니며, StateFlow와 달리 `.value` 속성도 존재하지 않는다
또한 StateFlow와 달리 중복된 값이 emit되는 것을 막지 않으며, emit된 값은 조건 없이 무조건 전파된다. 따라서 중복 처리나 debounce, throttle 등이 필요한 경우 외부에서 추가 처리가 필요하다

간단히 말하면 StateFlow는 “상태(state)를 항상 보존하며 관찰 가능한 흐름”이고, SharedFlow는 “상태는 없지만 이벤트를 여러 구독자에게 일시적으로 전파하는 흐름”이다
