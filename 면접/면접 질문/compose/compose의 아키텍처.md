Jetpack Compose에서 UI는 불변(immutable)이고, 한 번 그려지면 UI를 직접적으로 변경할 수 없다
대신, 상태(state)가 변경될 때마다 Compose는 상태변화가 영향을 미치는 UI 부분만 다시 그려주는 방식으로 동작한다

컴포저블은 상태를 받고 이벤트를 노출 할수 있다
그래서 단반향 데이터 흐름(UDF)이 Compose에 적합하다
UDF는 상태(value)는 아래로 이동하고 이벤트는 위로 이동하도록 하는 디자인 패턴이다
UDF 를 따르면 ui는 ui에 집중할수 있고 상태를 관리하는 부분을 분리할수 있다

UDF 를 사용하는 UI의 업데이트 흐름은

이벤트 -> UI 가 이벤트를 생성하고 상위 요소로 이벤트를 전달한다
상태 변경 -> 이벤트를 받은 상위요소는 이벤트의 종류에 따라서 상태를 업데이트하거나 다른 동작을 한다
상태 표시 -> 상위요소의 상태를 하위 UI로 전달한다

Compose 에서 UDF 를 사용하면 좋은 이유

상태를 UI(Composable 함수) 를 사용하는곳에서 임의로 전달할수 있어서 상태를 변경시키면서 UI테스트 할수있다(Preview)
UI 가 사용하는 상태의 원천이 하나여서 상태의 일관성이 높아져서 버그가 줄어든다
Compose 에서는 보통 StateFlow, LiveData 같은 observable 상태홀더를 사용해서 상태의 업데이트가 UI 에 즉시 반영된다

Composable 의 상태를 받는 파라미터를 받을때는

파라미터가 컴포저블의 성능에 미치는 영향과
컴포저블의 재사용성과 유연성을 고려해야한다

사용성 관점
파라미터에는 사용하지 않는 데이터가 들어오면 안된다
가능한 최소한의 정보를 전달해야한다

리컴포지션 관점
상태를 데이터 클래스형태로 전달하면 객체의 값이 안바뀌어도 인스턴스가 바뀌면 재구성을 한다(값이 바뀌지않으면 리컴포지션을 skip 하지만)
데이터클래스의 속성을 각각 매개변수로 전달하면 해당 값들에 변화가 있을때만 리컴포지션이 발생한다

그러나 메게변수가 너무 많으면 가독성이 떨어질수 있으니 데이터클래스의 사용을 고려할 필요도 있다 

```kotlin
@Composable
fun Header(title: String, subtitle: String) {
    // title이나 subtitle이 변경될 때만 재구성됨.
}
```

```kotlin
@Composable
fun Header(news: News) {
    // News 객체가 title, subtitle 이왜의 값을 가지고있으면 메모리 낭비가 있고,
    // 값을 전달하는곳에서도 News 객체를 만들어서 전달해야해서 불편할수 있다
    // 새로운 News 인스턴스가 전달될 때마다 재구성됨.
}
```

