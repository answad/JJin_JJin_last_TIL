컴포저블함수를 compose가 실행하면 컴포지션을 생성한다
컴포지션은 ui 를 설명하는 컴포저블의 트리이다
compose 는 초기에 컴포지션을 생성할때 ui 를 설명학 위해서 호출하는 모든 컴포저블의 상태의 변화를 추적하는데
상태가 변경되면 compose 는 리컴포지션을 예약한다 리컴포지션은 compose 가 상태 변화에 따라 변경될 수 있는 컴포저블함수를 다시 실행하고 변경사항을 ui에 반영할수 있도록 컴포지션(ui tree)를 업데이트하는것이다
컴포지션(ui tree)는 초기 컴포지션(compose가 컴포저블을 해석하는것)을 통해서만 생성할수 있고리컴포지션으로만 업데이트 할수 있다
#### 컴포저블의 생명주기는 컴포지션 시작, 0회 이상의 리컴포지션, 컴포지션 종료 3가지가 있다
리컴포지션은 보통의 경우에는 State<T> 객체가 변경되면 트리거 된다
compose는 이런 상태 객체를 추적하고 컴포지션에서 그 싱태를 읽거나 호출하는 모든 컴포저블중에서 skip 불가능한 모든 컴포저블을 리컴포지션한다

-----------

여기서부터는 compose가 각각의 composable 함수를 어떻게 구분하는지 서술할것이다

compsoe는 기본적으로 컴포저블이 어디서 호출됬는지(호출 사이트)로 구별한다 
리컴포지션을 할때 이전 컴포지션시에 호출한것과 다른 컴포저블을 추가로 호출할때 compsoe는 이전에 호출된 컴포저블과 이전에 호출되지 않은 컴포저블을 구분하고 이전에 호출된 컴포저블은 사용하는 상태가 변경되지 않은경우에 재구성하지 않고 skip 합니다 

동일한 호출 사이트에서 같은 컴포저블을 여러번 호출하는 경우에 compose가 각각의 컴포저블을 구별할수 있는 정보가 없음으로 컴포저블을 구분하기 위해 순서를 사용한다
그런데 호출 목록의 가장 위나 중간에 컴포저블을 추가하는 경우에는 많은 컴포저블의 순서가 변경됨으로 순서가 변경된 모든 컴포저블에서 리컴포지션이 트리거 된다
이럴때에 compose 가 각각의 컴포저블을 고유하게 인식할수 있도록 하려면 

![image](https://github.com/user-attachments/assets/00159d87-5510-4e3d-9566-fa5b2905a59b)

이런식으로 key 값으로 컴포저블을 감싸도록 하면 compose 가 각각의 컴포저블을 고유하게 인식할수 있다 
이 key 값은 같은 호출 사이트에서만 고유하면 문제가 없다
이런식으로 key 값을 전달하면 어떤식으로 순서가 변경되더라도 컴포저블을 재사용 할수 있다


--------

컴포저블이 skip 불가능한 경우
함수의 반환값이 Unit 이 아닌 경우
함수가 @NonRestartableComposable 또는 @NonSkippableComposable 어노테이션이 붙어있을때 
기본값이 없는 메게변수가 stable 하지 않은 type 일때 

타입이 stable 하다고 여겨지려면 
두 같은값의 두 인스턴스의 equals 값이 true 일때  
타입의 값이 변경되었을때 compose가 추적할수 있을때
